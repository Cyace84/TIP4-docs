# TIP4_1 (Non_fungible Token) Deployment

<div class="deployToken">

In this section will learn how to deploy the most simple part of the standard which is the raw implementation of the TIP4_1Collection and TIP4_1Nft contract.

Deploying these contracts will provide us the base functionality of the nft contracts on a TVM(Ton Virtual machine) based networks and shows us the workflow of the distributed implementation of the nft contracts on these type of blockchains.

We will be expecting base functionality presented by other NFT standard from our collection and nft contracts after deploying them which are containing following operations:

- Deploying the NFTs
- Transferring the NFTs


## Step 1: Prepare the Contracts

### Nft Contract

This contract will be deployed by the TIP4_1Collection contract and is the ones which performs the functionalities defined in the TIp4_1Nft contract such as transferring the Nfts.

make a file named `Nft.tsol` in the contracts folder and copy the code below into it.

<details>
<summary> show code</summary>

````solidity
pragma ever-solidity >= 0.61.2;

pragma AbiHeader expire;
pragma AbiHeader time;
pragma AbiHeader pubkey;


import '@broxus/tip4/contracts/TIP4_1/TIP4_1Nft.tsol';


contract Nft is TIP4_1Nft {

    constructor(
        address owner,
        address sendGasTo,
        uint128 remainOnNft
    ) TIP4_1Nft(
        owner,
        sendGasTo,
        remainOnNft
    ) public {
        tvm.accept();
    }

}
````

</details>

### Collection Contract

This Contract lets us inherit from the TIP4_1Collection contract functionalities which is a abstract contract and also implement the logic for deployments of the NFt contracts.

make a file named `Collection.tsol` in the contracts folder and copy the code below into it.

<details>
<summary> show code</summary>

````solidity

ppragma ever-solidity >= 0.61.2;

pragma AbiHeader expire;
pragma AbiHeader time;
pragma AbiHeader pubkey;


import '@broxus/tip4/contracts/access/OwnableExternal.tsol';
import '@broxus/tip4/contracts/TIP4_1/TIP4_1Collection.tsol';
import './Nft.tsol';

contract Collection is TIP4_1Collection, OwnableExternal {

    uint32 static _randomNonce;

    /**
    * Errors
    **/

    uint8 constant sender_is_not_owner = 100;
    uint8 constant value_is_less_than_required = 101;

    /// _remainOnNft - the number of crystals that will remain after the entire mint
    /// process is completed on the Nft contract
    uint128 _remainOnNft = 0.3 ever;

    constructor(
        TvmCell codeNft,
        uint256 ownerPubkey
    ) OwnableExternal (
        ownerPubkey
    ) TIP4_1Collection (
        codeNft
    ) public {
        tvm.accept();
    }

    function mintNft() external virtual {
        require(msg.value > _remainOnNft + 0.1 ever, value_is_less_than_required);
        tvm.rawReserve(0, 4);

        uint256 id = uint256(_totalSupply);
        _totalSupply++;
        TvmCell codeNft = _buildNftCode(address(this));
        TvmCell stateNft = _buildNftState(codeNft, id);
        address nftAddr = new Nft{
            stateInit: stateNft,
            value: 0,
            flag: 128
        }(
            msg.sender,
            msg.sender,
            _remainOnNft
        );

        emit NftCreated(
            id,
            nftAddr,
            msg.sender,
            msg.sender,
            msg.sender
        );

    }

    function setRemainOnNft(uint128 remainOnNft) external virtual {
        require(TIP4_1Collection._isOwner(), sender_is_not_owner);
        _remainOnNft = remainOnNft;
    }

    function _isOwner() internal override onlyOwner returns(bool){
        return true;
    }

    function _buildNftState(
        TvmCell code,
        uint256 id
    ) internal virtual override(TIP4_1Collection) pure returns (TvmCell) {
        return tvm.buildStateInit({
            contr: Nft,
            varInit: {_id: id},
            code: code
        });
    }

}
````

</details>


### Build the Contracts Artifacts

run the command below into your terminal to build the written contracts artifacts:

````shell

npx locklift build

````

### Store Contracts Code and tvc
In order to deploy a contract using the everscale-inpage-provider toll we need the targets contract code and tvc.


## Step 2: Write Deployment Script

<span  :class="LLdis"  >

Utilize the code sample below to deploy the contracts that we written previously using the locklift tool.

::: info
Before we start to write our scripts we need to make sure that there is a file named `01-deploy-tip4-1.ts` in the `script` folder in the project root.
:::

</span>

<span :class="EIPdis"  >

The code sample below is utilized to deploy the mentioned contract using everscale-inpage-provider tool.
We are having two function that each has a specific responsibility, deployTip4_1Collection function deploys the TIP4_1Collection and the other deployTip4_1Nft deploys the TIP4_1Nft contract.

</span>
<br/>

<div class="switcherContainer">

<button @click="llHandler" :class="llSwitcher">locklift</button>

<button @click="eipHandler" :class="eipSwitcher">everscale-inpage-provider </button>

</div>

<div class="codeBlockContainer" >

<span  :class="LLdis">

````typescript

import { Signer } from "everscale-standalone-client";
import { Address, WalletTypes } from "locklift";

async function deployTip4_1() {
  // Fetching the signer key pair from locklift.config.ts
  const signer: Signer = (await locklift.keystore.getSigner("0"))!;

  // uncomment if deploying a new account
  // const { contract: Account } = await locklift.factory.deployContract({
  //   contract: "Account",
  //   publicKey: signer.publicKey,
  //   constructorParams: {},
  //   initParams: { _randomNonce: locklift.utils.getRandomNonce() },
  //   value: locklift.utils.toNano(20),
  // });

  // Adding an existing SafeMultiSig Account using its address
  const account = await locklift.factory.accounts.addExistingAccount({
    type: WalletTypes.MsigAccount,
    address: new Address("YOUR_ACCOUNT_ADDRESS"), // if deploying new account >> Account.address
    mSigType: "SafeMultisig",
    publicKey: signer.publicKey,
  });

  const { contract: collectionContract } = await locklift.factory.deployContract({
    contract: "Collection",
    publicKey: signer.publicKey,
    constructorParams: {
      codeNft: locklift.factory.getContractArtifacts("Nft").code,
      ownerPubkey: `0x${signer.publicKey}`,
    },

    initParams: {
      _randomNonce: locklift.utils.getRandomNonce(),
    },
    value: locklift.utils.toNano(10),
  });

  console.log(`collection deployed to: ${collectionContract.address.toString()}`);

  await collectionContract.methods.mintNft({}).send({ from: account.address, amount: locklift.utils.toNano(2) });

  const nftAddress = (await collectionContract.methods.nftAddress({ answerId: 0, id: 0 }).call({})).nft;

  const nftContract = locklift.factory.getDeployedContract("Nft", nftAddress);

  console.log(await nftContract.methods.getInfo({ answerId: 0 }).call());
}
deployTip4_1()
  .then(res => {
    process.exit(0);
  })
  .catch(err => {
    console.log(err);
    process.exit(1);
  });

````

</span>

<span  :class="EIPdis">

````typescript
// Import the following libraries
import {
  Address,
  GetExpectedAddressParams,
  Contract,
  ProviderApiResponse,
  FullContractState,
  Transaction,
} from "everscale-inpage-provider";
import { provider, providerAddress } from "../helpers/useProviders";
import { factorySource, FactorySource } from "../build/factorySource";

async function deployTip4_1Collection() {

  try {
    // Collection contract abi
    const collectionAbi: FactorySource["Collection"] =
      factorySource["Collection"];

    // Define the deployParams type
    type DeployParams<Abi> = GetExpectedAddressParams<Abi> & {
      publicKey: string | undefined;
    };

    // Fetching the user public key
    const accountFullState: FullContractState = (
      await provider.getFullContractState({ address: providerAddress })
    ).state!;
    const senderPublicKey: string = await provider.extractPublicKey(
      accountFullState.boc!
    );

    // Fetching the tvc and the code of the nft contract
    const collectionTvc: string = await (
      await fetch("/scripts/build/Collection.base64")
    ).text();
    const nftTvc: string = await (
      await fetch("/scripts/build/Nft.base64")
    ).text();
    const nftCode: string = (await provider.splitTvc(nftTvc)).code!;

    /**
     * Preparing deploy params to build the state init with the contract abi
     */
    const deployParams: DeployParams<FactorySource["Collection"]> = {
      tvc: collectionTvc,
      workchain: 0,
      publicKey: senderPublicKey,
      initParams: {
        _randomNonce: (Math.random() * 6400) | 0,
      },
    };

    // Get the expected contract address
    const expectedAddress: Address = await provider.getExpectedAddress(
      collectionAbi,
      deployParams
    );

    // Get the state init
    const stateInit: ProviderApiResponse<"getExpectedAddress"> =
      await provider.getStateInit(collectionAbi, deployParams);
    stateInit.stateInit;

    // Send the coins to the calculated address
    await provider.sendMessage({
      sender: providerAddress,
      recipient: expectedAddress,
      amount: String(2 * 10 ** 9),
      bounce: false, // it's important to set this param to keep the evers in the contract
      stateInit: stateInit.stateInit,
    });

    // Create a contract instance
    const collectionContract: Contract<FactorySource["Collection"]> =
      new provider.Contract(collectionAbi, expectedAddress);

    // Call the contract constructor
    const { transaction: deployRes } = await collectionContract.methods
      .constructor({
        codeNft: nftCode,
        ownerPubkey: `0x${deployParams.publicKey!}`,
      })
      .sendExternal({
        stateInit: stateInit.stateInit,
        publicKey: deployParams.publicKey!,
      });

    // checking if the collection contract is deployed successfully by calling its name method
    const totalSupply: string = (
      await collectionContract.methods.totalSupply({ answerId: 0 }).call()
    ).count;

    if (totalSupply == "0") {
      console.log(`TIP4_1 collection deployed to ${expectedAddress.toString()}`);
    } else {
      console.log(`TIP4_1 collection deployment failed ! ${
        (deployRes.exitCode, deployRes.resultCode)
      }`);
    }
  } catch (err: any) {
    toast(err.message);
    return err.message;
  }
}
````

````typescript
 async function deployTip4_1Nft(CollectionAddr: string) {
  try {

    // Collection and the Nft contracts abis
    const collectionAbi: FactorySource["Collection"] =
      factorySource["Collection"];
    const nftAbi: FactorySource["Nft"] = factorySource["Nft"];

    const collectionContract: Contract<FactorySource["Collection"]> =
      new provider.Contract(collectionAbi, new Address(CollectionAddr));

    // deploying an nft from the collection contract
    const totalSupply = Number(
      (await collectionContract.methods.totalSupply({ answerId: 0 }).call())
        .count
    );

    // Minting(deploying) an Nft contract
    const mintRes: Transaction = await collectionContract.methods
      .mintNft({})
      .send({
        from: providerAddress,
        amount: String(2 * 10 ** 9),
        bounce: true,
      });

    // Checking if the Nft contract is deployed successfully
    if (mintRes.aborted)
      return `minting Nft failed ${(mintRes.exitCode, mintRes.resultCode)}`;

    // fetching the newly deployed nft contract
    const nftAddr: Address = (
      await collectionContract.methods
        .nftAddress({
          answerId: 0,
          id: totalSupply + 1,
        })
        .call()
    ).nft;

    const nftContract: Contract<FactorySource["Nft"]> = new provider.Contract(
      nftAbi,
      nftAddr
    );

    // Getting the info of the nft contract ot check the validity of its data
    const nftContractData = await nftContract.methods
      .getInfo({ answerId: 0 })
      .call();

    if (nftContractData.collection.toString() == CollectionAddr.toString()) {
      console.log(`Nft number ${nftContractData.id} deployed to ${nftAddr.toString()}`);
    } else {
      console.log(`TIP4_1 Nft deployment failed ! ${
        (mintRes.exitCode, mintRes.resultCode)
      }`);
    }
  } catch (err: any) {
    console.log(err.message);
    return err.message;
  }
}

````

</span>

</div>


<div class="action">

## Step 3: Deploy the NFT

<div :class="llAction">

Use this command to deploy TIP-3 tokens:

```shell
npx locklift run -s ./scripts/01-deploy-tip4-1.ts -n local
```
<ImgContainer src= '/typical01.png' width="100%" altText="deployTip3Output" />

Congratulations, you have successfully deployed your first NFT contract using the TIP4_1 standard 🎉

</div>

<div :class="eipAction" >

<div :class="deploy">

### Deploy TIP4_1 Collection

<button @click="deployCollection" class="deployTokenBut" >deploy collection</button>

<!-- </div> -->
<p id="output-p" :class="EIPdis"><loading :text="loadingText"/></p>

### Deploy TIP4_1 Nft

<!-- <div class="deployByRoot"> -->

<p class=actionInName style="margin-bottom: 0;">Collection Address</p>

<input ref="actionCollectionAddress" class="action Ain" type="text"/>

<button @click="deployNft" class="deployTokenBut" >Mint Nft</button>

<p id="output-p" :class="EIPdis"><loading :text="loadingText2"/></p>

</div>

</div>

</div>

</div>

<script lang="ts" >
import { defineComponent, ref, onMounted } from "vue";
import {toast} from "/src/helpers/toast";
import ImgContainer from "../../../.vitepress/theme/components/shared/BKDImgContainer.vue"
import loading from "../../../.vitepress/theme/components/shared/BKDLoading.vue"
import {deployTip4_1Collection, deployTip4_1Nft} from "../../../scripts/typical/tip4_1";

export default defineComponent({
  name: "deployToken",
      components :{
    ImgContainer,
    loading
  },
  data(){
    return{
        LLdis: "cbShow",
        EIPdis: "cbHide",
        llSwitcher:"llSwitcher on",
        eipSwitcher: "eipSwitcher off",
        llAction: "llAction cbShow",
        eipAction: "eipAction cbHide",
        loadingText: " ",
        loadingText2: " "
        }
  },
  setup() {

    function llHandler(e){
        if(this.LLdis == "cbHide")
        {
            this.llSwitcher = "llSwitcher on";
            this.eipSwitcher = "eipSwitcher off"
        };
        this.EIPdis = "cbHide"
        this.LLdis = "cbShow"
        this.llAction = "llAction cbShow"
        this.eipAction = "eipAction cbHide"
}
    async function eipHandler(e){
        if(this.EIPdis == "cbHide")
        {
            this.llSwitcher = "llSwitcher off";
            this.eipSwitcher = "eipSwitcher on"
        };
        this.LLdis = "cbHide"
        this.EIPdis = "cbShow"
        this.llAction = "llAction cbHide"
        this.eipAction = "eipAction cbShow"
    }
  async function deployCollection(){
          this.loadingText = ""
        let deployTokenRes = await deployTip4_1Collection()
          // Rendering the output
          deployTokenRes = !deployTokenRes ? "Failed" :  deployTokenRes;
          this.loadingText = deployTokenRes;
  }

   async function deployNft(){
          this.loadingText2 = ""
        if (
            this.$refs.actionCollectionAddress.value == ""

        ){
            toast("Collection address field is required !", 0)
            this.loadingText2 = "Failed"
            return
        }

        let deployTokenRes = await deployTip4_1Nft(this.$refs.actionCollectionAddress.value)

          // Rendering the output
          deployTokenRes = !deployTokenRes ? "Failed" :  deployTokenRes;
          this.loadingText2 = deployTokenRes;
  }

return {
        eipHandler,
        llHandler,
        deployNft,
        deployCollection
    };
  },
});

</script>

<style>

.action{
    display:inline-block;
}

.actionInName{
    font-size: .9rem;
}

.deployTokenBut, .switcherContainer, .codeBlockContainer, .Ain, details
{
  background-color: var(--vp-c-bg-mute);
  transition: background-color 0.1s;
  border: 1px solid var(--vp-c-divider);
  border-radius: 8px;
  font-weight: 600;
  cursor : pointer;
}

details{
    padding : 0 10px 0 10px;
}
.Ain{
    padding-left : 10px;
    margin : 0;
}
.deployTokenBut{
    cursor:pointer;
    padding: 5px 12px;
    display: flex;
    transition: all ease .3s;
}

.deployTokenBut:hover{
      border: 1px solid var(--light-color-ts-class);
}

#output-p{
    /* height: 30px; */
    padding: 2px 10px;
    border-radius: 8px;
    border: 1px solid var(--vp-c-divider);
    }

.text{padding-left: 5px;font-size:1rem;}

.switcherContainer{
    border-bottom-left-radius: 0;
    border-bottom-right-radius: 0;
    display: flex;
    border: none;
    padding: 0px;
}
.switcherContainer > p{
    margin: 0px;
    padding : 0px;
}
.codeBlockContainer{
    border-top-left-radius: 0;
    border-top-right-radius: 0;
    padding: 8px 12px;
}
.cbShow{
    display: block;
}
.cbHide{
    display: none;
}
.llSwitcher{
    padding: 5px 10px;
    border:  0 solid var(--vp-c-divider);
    border-width: 1px ;
    border-color: var(--vp-c-divider);
    border-top-left-radius: 8px;
    border-top-right-radius: 8px;
    font-weight: 600;
    transition: all ease .2s;
}
.eipSwitcher{
    padding: 5px 10px;
    border:  0 solid var(--vp-c-divider);
    border-width: 1px ;
    border-color: var(--vp-c-divider);
    border-top-left-radius: 8px;
    border-top-right-radius: 8px;
    font-weight: 600;
    transition: all ease .2s;
}
.llSwitcher:hover, .eipSwitcher:hover{
      border-color: var(--light-color-ts-class);
}
.eipAction{
    font-weight: 600;
}
.on{
    color : var(--light-color-ts-class);
}
.off{
    color : var(--vp-c-bg-mute);
}

* {box-sizing: border-box;}

.container {
  display: flex;
  position: relative;
  margin-bottom: 12px;
  font-size: .9rem;
}

.container .checkboxInput {
  position: absolute;
  opacity: 0;
  height: 0;
  width: 0;

}

.checkmark {
  cursor: pointer;
  position: relative;
  top: 0;
  left: 0;
  height: 25px;
  width: 25px;
  background-color: var(--vp-c-bg-mute);
  border: 1px solid var(--vp-c-divider);
  border-radius : 8px;
  margin-left: 10px;
}

.container input:checked ~ .checkmark {
  background-color: var(--light-color-ts-class);
}

.checkmark:after {
  content: "";
  position: absolute;
  display: none;
}

.container input:checked ~ .checkmark:after {
  display: block;
}

.container .checkmark:after {
  left: 9px;
  top: 5px;
  width: 5px;
  height: 10px;
  border: solid white;
  border-width: 0 3px 3px 0;
  -webkit-transform: rotate(45deg);
  -ms-transform: rotate(45deg);
  transform: rotate(45deg);
}

</style>